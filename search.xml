<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="2021/02/16/hello-world/"/>
      <url>2021/02/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker --开源的应用容器引擎</title>
      <link href="2019/06/19/howtousedocker/"/>
      <url>2019/06/19/howtousedocker/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Docker-是什么？"><a href="#一、Docker-是什么？" class="headerlink" title="一、Docker 是什么？"></a>一、Docker 是什么？</h1><p><img src="https://www.runoob.com/wp-content/uploads/2016/04/docker01.png" alt="Docker"></p><h2 id="1-Docker-简介"><a href="#1-Docker-简介" class="headerlink" title="1.Docker 简介"></a>1.Docker 简介</h2><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。<br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。它提供了一个简单、轻量的建模方式，使开发生命周期更高效快速，鼓励了面向服务的架构设计。Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）等技术。在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。<br>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。<br>适用人群：运维工程师及后端开发人员</p><h2 id="2-Docker-应用场景"><a href="#2-Docker-应用场景" class="headerlink" title="2.Docker 应用场景"></a>2.Docker 应用场景</h2><p>Web 应用的自动化打包和发布。<br>自动化测试和持续集成、发布。<br>在服务型环境中部署和调整数据库或其他的后台应用。<br>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</p><h2 id="3-Docker-的优点"><a href="#3-Docker-的优点" class="headerlink" title="3.Docker 的优点"></a>3.Docker 的优点</h2><ul><li>简化程序：<br>Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的任务，在Docker容器的处理下，只需要数秒就能完成。</li><li>避免选择恐惧症：<br>如果你有选择恐惧症，还是资深患者。Docker 帮你打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。</li><li>节省开支：<br>一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</li></ul><h2 id="4-Docker-的特点"><a href="#4-Docker-的特点" class="headerlink" title="4.Docker 的特点"></a>4.Docker 的特点</h2><ul><li>更快速的交付和部署</li><li>更高效的虚拟化</li><li>更轻松的迁移和扩展</li><li>更简单的管理</li><li>容器技术与传统虚拟机性能对比</li></ul><p><img src="https://mc.qcloudimg.com/static/img/22ee2d58d0cdc02c906239ee10e022ef/image.png" alt="容器技术与传统虚拟机性能对比"></p><p><strong>Docker与虚拟机建构对比</strong><br><img src="https://mc.qcloudimg.com/static/img/6afde94bc4570cba2c9e27f0bdc81350/image.png" alt="Docker与虚拟机建构对比"></p><p><strong>Docker 容器本质上是宿主机上的一个进程。</strong>Docker 通过 namespace 实现了资源隔离，通过 cgroups 实现了资源的限制，通过写时复制机制（copy-on-write）实现了高效的文件操作。<br><strong>Docker有五个命名空间：进程、网络、挂载、宿主和共享内存。</strong>为了隔离有问题的应用，Docker运用Namespace将进程隔离，为进程或进程组创建已隔离的运行空间，为进程提供不同的命名空间视图。这样，每一个隔离出来的进程组，对外就表现为一个container(容器)。需要注意的是，Docker让用户误以为自己占据了全部资源，但这并不是”虚拟机”。</p><h2 id="5-Docker-中的三个概念：镜像，容器，仓库"><a href="#5-Docker-中的三个概念：镜像，容器，仓库" class="headerlink" title="5.Docker 中的三个概念：镜像，容器，仓库"></a>5.Docker 中的三个概念：镜像，容器，仓库</h2><ul><li>镜像（image）：Docker 镜像就是一个只读的模板，镜像可以用来创建 Docker 容器。Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。<br>镜像是一种文件结构。Dockerfile中的每条命令都会在文件系统中创建一个新的层次结构，文件系统在这些层次上构建起来，镜像就构建于这些联合的文件系统之上。Docker官方网站专门有一个页面来存储所有可用的镜像，网址是：index.docker.io。</li><li>容器（ Container）：容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的 Linux 环境，Docker 利用容器来运行应用。镜像是只读的，容器在启动的时候创建一层可写层作为最上层。</li><li>仓库：仓库是集中存放镜像文件的场所，仓库注册服务器（Registry）上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。目前，最大的公开仓库是 Docker Hub，存放了数量庞大的镜像供用户下载。</li></ul><p>Docker仓库用来保存我们的images，当我们创建了自己的image之后我们就可以使用push命令将它上传到公有或者私有仓库，这样下次要在另外一台机器上使用这个image时候，只需要从仓库上pull下来就可以了。Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。</p><h1 id="二、Docker-安装（CentOS-7-下）"><a href="#二、Docker-安装（CentOS-7-下）" class="headerlink" title="二、Docker 安装（CentOS 7 下）"></a>二、Docker 安装（CentOS 7 下）</h1><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。<br>通过 uname -r 命令查看你当前的内核版本</p><pre><code>[root@runoob ~]# uname -r </code></pre><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>从 2017 年 3 月开始 docker 在原来的基础上分为两个分支版本: Docker CE 和 Docker EE。<br>Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。<br>本文介绍 Docker CE 的安装使用。<br>移除旧的版本：</p><pre><code>$ sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-selinux \                  docker-engine-selinux \                  docker-engine</code></pre><p>安装一些必要的系统工具：</p><pre><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre><p>添加软件源信息：</p><pre><code>sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><p>更新 yum 缓存：</p><pre><code>sudo yum makecache fast</code></pre><p>安装 Docker-ce：</p><pre><code>sudo yum -y install docker-ce</code></pre><p>启动 Docker 后台服务</p><pre><code>sudo systemctl start docker</code></pre><p>测试运行 hello-world</p><pre><code>[root@runoob ~]# docker run hello-world</code></pre><p>由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行。</p><h2 id="使用脚本安装-Docker"><a href="#使用脚本安装-Docker" class="headerlink" title="使用脚本安装 Docker"></a>使用脚本安装 Docker</h2><p>1、使用 sudo 或 root 权限登录 Centos。<br>2、确保 yum 包更新到最新。</p><pre><code>$ sudo yum update</code></pre><p>3、执行 Docker 安装脚本。</p><pre><code>$ curl -fsSL https://get.docker.com -o get-docker.sh$ sudo sh get-docker.sh</code></pre><p>执行这个脚本会添加 docker.repo 源并安装 Docker。<br>4、启动 Docker 进程。</p><pre><code>sudo systemctl start docker</code></pre><p>5、验证 docker 是否安装成功并在容器中执行一个测试的镜像。</p><pre><code>$ sudo docker run hello-worlddocker ps</code></pre><p>到此，Docker 在 CentOS 系统的安装完成。</p><h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，我们可以需要配置加速器来解决，我使用的是网易的镜像地址：<a href="http://hub-mirror.c.163.com。" target="_blank" rel="noopener">http://hub-mirror.c.163.com。</a><br>新版的 Docker 使用 /etc/docker/daemon.json（Linux） 或者 %programdata%\docker\config\daemon.json（Windows） 来配置 Daemon。<br>请在该配置文件中加入（没有该文件的话，请先建一个）：</p><pre><code>{  &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]}</code></pre><h2 id="删除-Docker-CE"><a href="#删除-Docker-CE" class="headerlink" title="删除 Docker CE"></a>删除 Docker CE</h2><p>执行以下命令来删除 Docker CE：</p><pre><code>$ sudo yum remove docker-ce$ sudo rm -rf /var/lib/docker</code></pre><p><a href="https://www.runoob.com/docker/centos-docker-install.html" target="_blank" rel="noopener">其他系统的安装docker</a></p><h1 id="三、Docker-的简单使用"><a href="#三、Docker-的简单使用" class="headerlink" title="三、Docker 的简单使用"></a>三、Docker 的简单使用</h1><p>Docker 允许你在容器内运行应用程序， 使用 docker run 命令来在容器内运行一个应用程序。<br>输出Hello world</p><pre><code>runoob@runoob:~$ docker run ubuntu:15.10 /bin/echo &quot;Hello world&quot;Hello world</code></pre><p><strong>各个参数解析：</strong><br>docker: Docker 的二进制执行文件。<br>run:与前面的 docker 组合来运行一个容器。<br>ubuntu:15.10指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。<br>/bin/echo “Hello world”: 在启动的容器里执行的命令</p><p>以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo “Hello world”，然后输出结果。</p><hr><p>运行交互式的容器<br>我们通过docker的两个参数 -i -t，让docker运行的容器实现”对话”的能力</p><pre><code>runoob@runoob:~$ docker run -i -t ubuntu:15.10 /bin/bashroot@dc0050c79503:/#</code></pre><p>各个参数解析：<br>-t:在新容器内指定一个伪终端或终端。<br>-i:允许你对容器内的标准输入 (STDIN) 进行交互。<br>此时我们已进入一个 ubuntu15.10系统的容器<br>我们尝试在容器中运行命令 cat /proc/version和ls分别查看当前系统的版本信息和当前目录下的文件列表</p><p>我们可以通过运行exit命令或者使用CTRL+D来退出容器。</p><hr><p>启动容器（后台模式）<br>使用以下命令创建一个以进程方式运行的容器</p><pre><code>runoob@runoob:~$ docker run -d ubuntu:15.10 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63</code></pre><p>在输出中，我们没有看到期望的”hello world”，而是一串长字符<br>2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63<br>这个长字符串叫做容器ID，对每个容器来说都是唯一的，我们可以通过容器ID来查看对应的容器发生了什么。<br>首先，我们需要确认容器有在运行，可以通过 docker ps 来查看</p><pre><code>runoob@runoob:~$ docker ps</code></pre><p>CONTAINER ID:容器ID<br>NAMES:自动分配的容器名称<br>在容器内使用docker logs命令，查看容器内的标准输出</p><pre><code>runoob@runoob:~$ docker logs 2b1b7a428627</code></pre><pre><code>runoob@runoob:~$ docker logs amazing_cori</code></pre><hr><p>停止容器<br>我们使用 docker stop 命令来停止容器:</p><p>通过docker ps查看，容器已经停止工作:</p><pre><code>runoob@runoob:~$ docker ps</code></pre><p>也可以用下面的命令来停止:</p><pre><code>runoob@runoob:~$ docker stop amazing_cori</code></pre><h1 id="四、Docker-常用命令"><a href="#四、Docker-常用命令" class="headerlink" title="四、Docker 常用命令"></a>四、Docker 常用命令</h1><h2 id="1-信息-版本"><a href="#1-信息-版本" class="headerlink" title="1.信息/版本"></a>1.信息/版本</h2><p>docker info：显示 Docker 系统信息，包括镜像和容器数。。</p><p>docker version：显示 Docker 版本信息。</p><h2 id="2-容器生命周期管理"><a href="#2-容器生命周期管理" class="headerlink" title="2.容器生命周期管理"></a>2.容器生命周期管理</h2><h3 id="1-Docker-run-命令"><a href="#1-Docker-run-命令" class="headerlink" title="1).Docker run 命令:"></a>1).Docker run 命令:</h3><p>docker run ：创建一个新的容器并运行一个命令</p><pre><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></pre><p><strong>OPTIONS说明：</strong><br>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；<br>-d: 后台运行容器，并返回容器ID；<br>-i: 以交互模式运行容器，通常与 -t 同时使用；<br>-P: 随机端口映射，容器内部端口随机映射到主机的高端口<br>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口<br>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br>–name=”nginx-lb”: 为容器指定一个名称；<br>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；<br>–dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；<br>-h “mars”: 指定容器的hostname；<br>-e username=”ritchie”: 设置环境变量；<br>–env-file=[]: 从指定文件读入环境变量；<br>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行；<br>-m :设置容器使用内存最大值；<br>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；<br>–link=[]: 添加链接到另一个容器；<br>–expose=[]: 开放一个端口或一组端口；</p><p><strong>实例</strong><br>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</p><pre><code>docker run --name mynginx -d nginx:latest</code></pre><p>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</p><pre><code>docker run -P -d nginx:latest</code></pre><p>使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。</p><pre><code>docker run -p 80:80 -v /data:/data -d nginx:latest</code></pre><p>绑定容器的 8080 端口，并将其映射到本地主机 127.0.0.1 的 80 端口上。</p><pre><code>$ docker run -p 127.0.0.1:80:8080/tcp ubuntu bash</code></pre><p>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</p><pre><code>runoob@runoob:~$ docker run -it nginx:latest /bin/bashroot@b8573233d675:/# </code></pre><h3 id="2-Docker-start-stop-restart-命令"><a href="#2-Docker-start-stop-restart-命令" class="headerlink" title="2).Docker start/stop/restart 命令"></a>2).Docker start/stop/restart 命令</h3><p>docker start :启动一个或多个已经被停止的容器<br>docker stop :停止一个运行中的容器<br>docker restart :重启容器<br><strong>语法</strong></p><pre><code>docker start [OPTIONS] CONTAINER [CONTAINER...]docker stop [OPTIONS] CONTAINER [CONTAINER...]docker restart [OPTIONS] CONTAINER [CONTAINER...]</code></pre><p><strong>实例</strong><br>启动已被停止的容器myrunoob</p><pre><code>docker start myrunoob</code></pre><p>停止运行中的容器myrunoob</p><pre><code>docker stop myrunoob</code></pre><p>重启容器myrunoob</p><pre><code>docker restart myrunoob</code></pre><h3 id="3-Docker-kill-命令"><a href="#3-Docker-kill-命令" class="headerlink" title="3).Docker kill 命令"></a>3).Docker kill 命令</h3><p>docker kill :杀掉一个运行中的容器。<br><strong>语法</strong></p><pre><code>docker kill [OPTIONS] CONTAINER [CONTAINER...]</code></pre><p><strong>OPTIONS说明：</strong><br>-s :向容器发送一个信号<br><strong>实例</strong><br>杀掉运行中的容器mynginx</p><pre><code>runoob@runoob:~$ docker kill -s KILL mynginxmynginx</code></pre><h3 id="4-Docker-rm-命令"><a href="#4-Docker-rm-命令" class="headerlink" title="4).Docker rm 命令"></a>4).Docker rm 命令</h3><p>docker rm ：删除一个或多少容器<br><strong>语法</strong></p><pre><code>docker rm [OPTIONS] CONTAINER [CONTAINER...]</code></pre><p><strong>OPTIONS说明：</strong><br>-f :通过SIGKILL信号强制删除一个运行中的容器<br>-l :移除容器间的网络连接，而非容器本身<br>-v :-v 删除与容器关联的卷<br><strong>实例</strong><br>强制删除容器db01、db02</p><pre><code>docker rm -f db01 db02</code></pre><p>移除容器nginx01对容器db01的连接，连接名db</p><pre><code>docker rm -l db </code></pre><p>删除容器nginx01,并删除容器挂载的数据卷</p><pre><code>docker rm -v nginx01</code></pre><h3 id="5-Docker-pause-unpause-命令"><a href="#5-Docker-pause-unpause-命令" class="headerlink" title="5).Docker pause/unpause 命令"></a>5).Docker pause/unpause 命令</h3><p>docker pause :暂停容器中所有的进程。<br>docker unpause :恢复容器中所有的进程。<br><strong>语法</strong></p><pre><code>docker pause [OPTIONS] CONTAINER [CONTAINER...]docker unpause [OPTIONS] CONTAINER [CONTAINER...]</code></pre><p><strong>实例</strong><br>暂停数据库容器db01提供服务。</p><pre><code>docker pause db01</code></pre><p>恢复数据库容器db01提供服务。</p><pre><code>docker unpause db01</code></pre><p>6).Docker create 命令<br>docker create ：创建一个新的容器但不启动它<br>用法同 docker run<br><strong>语法</strong></p><pre><code>docker create [OPTIONS] IMAGE [COMMAND] [ARG...]</code></pre><p>语法同 docker run<br><strong>实例</strong><br>使用docker镜像nginx:latest创建一个容器,并将容器命名为myrunoob</p><pre><code>runoob@runoob:~$ docker create  --name myrunoob  nginx:latest      09b93464c2f75b7b69f83d56a9cfc23ceb50a48a9db7652ee4c27e3e2cb1961f</code></pre><p>7).Docker exec 命令<br>docker exec ：在运行的容器中执行命令<br><strong>语法</strong></p><pre><code>docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</code></pre><p><strong>OPTIONS说明：</strong><br>-d :分离模式: 在后台运行<br>-i :即使没有附加也保持STDIN 打开<br>-t :分配一个伪终端<br><strong>实例</strong><br>在容器 mynginx 中以交互模式执行容器内 /root/runoob.sh 脚本:</p><pre><code>runoob@runoob:~$ docker exec -it mynginx /bin/sh /root/runoob.shhttp://www.runoob.com/</code></pre><p>在容器 mynginx 中开启一个交互模式的终端:</p><pre><code>runoob@runoob:~$ docker exec -i -t  mynginx /bin/bashroot@b1a0703e41e7:/#</code></pre><p>也可以通过 docker ps -a 命令查看已经在运行的容器，然后使用容器 ID 进入容器。<br>查看已经在运行的容器 ID：</p><pre><code>docker ps -a ...9df70f9a0714        openjdk             &quot;/usercode/script.sh…&quot; ...</code></pre><p>第一列的 9df70f9a0714 就是容器 ID。<br>通过 exec 命令对指定的容器执行 bash:</p><pre><code>docker exec -it 9df70f9a0714 /bin/bash</code></pre><h2 id="3-容器操作"><a href="#3-容器操作" class="headerlink" title="3.容器操作"></a>3.容器操作</h2><h3 id="1-Docker-ps-命令"><a href="#1-Docker-ps-命令" class="headerlink" title="1).Docker ps 命令"></a>1).Docker ps 命令</h3><p>docker ps : 列出容器<br><strong>语法</strong></p><pre><code>docker ps [OPTIONS]</code></pre><p><strong>OPTIONS说明：</strong><br>-a :显示所有的容器，包括未运行的。<br>-f :根据条件过滤显示的内容。<br>–format :指定返回值的模板文件。<br>-l :显示最近创建的容器。<br>-n :列出最近创建的n个容器。<br>–no-trunc :不截断输出。<br>-q :静默模式，只显示容器编号。<br>-s :显示总的文件大小。<br><strong>实例</strong><br>列出所有在运行的容器信息。</p><pre><code>runoob@runoob:~$ docker psCONTAINER ID   IMAGE          COMMAND                ...  PORTS                    NAMES09b93464c2f7   nginx:latest   &quot;nginx -g &#39;daemon off&quot; ...  80/tcp, 443/tcp          myrunoob96f7f14e99ab   mysql:5.6      &quot;docker-entrypoint.sh&quot; ...  0.0.0.0:3306-&gt;3306/tcp   mymysql</code></pre><p>列出最近创建的5个容器信息。</p><pre><code>runoob@runoob:~$ docker ps -n 5CONTAINER ID        IMAGE               COMMAND                   CREATED           09b93464c2f7        nginx:latest        &quot;nginx -g &#39;daemon off&quot;    2 days ago   ...     b8573233d675        nginx:latest        &quot;/bin/bash&quot;               2 days ago   ...     b1a0703e41e7        nginx:latest        &quot;nginx -g &#39;daemon off&quot;    2 days ago   ...    f46fb1dec520        5c6e1090e771        &quot;/bin/sh -c &#39;set -x \t&quot;   2 days ago   ...   a63b4a5597de        860c279d2fec        &quot;bash&quot;                    2 days ago   ...</code></pre><p>列出所有创建的容器ID。</p><pre><code>runoob@runoob:~$ docker ps -a -q09b93464c2f7b8573233d675b1a0703e41e7f46fb1dec520a63b4a5597de6a4aa42e947bde7bb36e796843a432b73776664a8ab1a585ba52eb632bbd...</code></pre><h3 id="2-Docker-inspect-命令"><a href="#2-Docker-inspect-命令" class="headerlink" title="2).Docker inspect 命令"></a>2).Docker inspect 命令</h3><p>docker inspect : 获取容器/镜像的元数据。<br><strong>语法</strong></p><pre><code>docker inspect [OPTIONS] NAME|ID [NAME|ID...]</code></pre><p><strong>OPTIONS说明：</strong><br>-f :指定返回值的模板文件。<br>-s :显示总的文件大小。<br>–type :为指定类型返回JSON。<br><strong>实例</strong><br>获取镜像mysql:5.6的元信息。</p><pre><code>runoob@runoob:~$ docker inspect mysql:5.6[    {        &quot;Id&quot;: &quot;sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec&quot;,        &quot;RepoTags&quot;: [            &quot;mysql:5.6&quot;        ],        &quot;RepoDigests&quot;: [],        &quot;Parent&quot;: &quot;&quot;,        &quot;Comment&quot;: &quot;&quot;,        &quot;Created&quot;: &quot;2016-05-24T04:01:41.168371815Z&quot;,        &quot;Container&quot;: &quot;e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54&quot;,        &quot;ContainerConfig&quot;: {            &quot;Hostname&quot;: &quot;b0cf605c7757&quot;,            &quot;Domainname&quot;: &quot;&quot;,            &quot;User&quot;: &quot;&quot;,            &quot;AttachStdin&quot;: false,            &quot;AttachStdout&quot;: false,            &quot;AttachStderr&quot;: false,            &quot;ExposedPorts&quot;: {                &quot;3306/tcp&quot;: {}            },...</code></pre><p>获取正在运行的容器mymysql的 IP。</p><pre><code>runoob@runoob:~$ docker inspect --format=&#39;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#39; mymysql172.17.0.3</code></pre><h3 id="3-Docker-top-命令"><a href="#3-Docker-top-命令" class="headerlink" title="3).Docker top 命令"></a>3).Docker top 命令</h3><p>docker top :查看容器中运行的进程信息，支持 ps 命令参数。<br><strong>语法</strong></p><pre><code>docker top [OPTIONS] CONTAINER [ps OPTIONS]</code></pre><p>容器运行时不一定有/bin/bash终端来交互执行top命令，而且容器还不一定有top命令，可以使用docker top来实现查看container中正在运行的进程。<br><strong>实例</strong><br>查看容器mymysql的进程信息。</p><pre><code>runoob@runoob:~/mysql$ docker top mymysqlUID    PID    PPID    C      STIME   TTY  TIME       CMD999    40347  40331   18     00:58   ?    00:00:02   mysqld</code></pre><p>查看所有运行容器的进程信息。</p><pre><code>for i in  `docker ps |grep Up|awk &#39;{print $1}&#39;`;do echo \ &amp;&amp;docker top $i; done</code></pre><h3 id="4-Docker-logs-命令"><a href="#4-Docker-logs-命令" class="headerlink" title="4).Docker logs 命令"></a>4).Docker logs 命令</h3><p>docker logs : 获取容器的日志<br><strong>语法</strong></p><pre><code>docker logs [OPTIONS] CONTAINER</code></pre><p><strong>OPTIONS说明：</strong><br>-f : 跟踪日志输出<br>–since :显示某个开始时间的所有日志<br>-t : 显示时间戳<br>–tail :仅列出最新N条容器日志<br><strong>实例</strong><br>跟踪查看容器mynginx的日志输出。</p><pre><code>runoob@runoob:~$ docker logs -f mynginx192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;2016/07/10 16:53:33 [error] 5#5: *1 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;192.168.239.130&quot;, referrer: &quot;http://192.168.239.130/&quot;192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 571 &quot;http://192.168.239.130/&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;...</code></pre><p>查看容器mynginx从2016年7月1日后的最新10条日志。</p><pre><code>docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx</code></pre><h2 id="4-容器rootfs命令"><a href="#4-容器rootfs命令" class="headerlink" title="4.容器rootfs命令"></a>4.容器rootfs命令</h2><h3 id="1-Docker-commit-命令"><a href="#1-Docker-commit-命令" class="headerlink" title="1).Docker commit 命令"></a>1).Docker commit 命令</h3><p>docker commit :从容器创建一个新的镜像。<br><strong>语法</strong></p><pre><code>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</code></pre><p><strong>OPTIONS说明：</strong><br>-a :提交的镜像作者；<br>-c :使用Dockerfile指令来创建镜像；<br>-m :提交时的说明文字；<br>-p :在commit时，将容器暂停。<br><strong>实例</strong><br>将容器a404c6c174a2 保存为新的镜像,并添加提交人信息和说明信息。</p><pre><code>runoob@runoob:~$ docker commit -a &quot;runoob.com&quot; -m &quot;my apache&quot; a404c6c174a2  mymysql:v1 sha256:37af1236adef1544e8886be23010b66577647a40bc02c0885a6600b33ee28057runoob@runoob:~$ docker images mymysql:v1REPOSITORY          TAG                 IMAGE ID            CREATED             SIZEmymysql             v1                  37af1236adef        15 seconds ago      329 MB</code></pre><h3 id="2-Docker-cp-命令"><a href="#2-Docker-cp-命令" class="headerlink" title="2).Docker cp 命令"></a>2).Docker cp 命令</h3><p>docker cp :用于容器与主机之间的数据拷贝。<br><strong>语法</strong></p><pre><code>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</code></pre><p><strong>OPTIONS说明：</strong><br>-L :保持源目标中的链接<br><strong>实例</strong><br>将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。</p><pre><code>docker cp /www/runoob 96f7f14e99ab:/www/</code></pre><p>将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。</p><pre><code>docker cp /www/runoob 96f7f14e99ab:/www</code></pre><p>将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。</p><pre><code>docker cp  96f7f14e99ab:/www /tmp/</code></pre><h3 id="3-Docker-diff-命令"><a href="#3-Docker-diff-命令" class="headerlink" title="3).Docker diff 命令"></a>3).Docker diff 命令</h3><p>docker diff : 检查容器里文件结构的更改。<br><strong>语法</strong></p><pre><code>docker diff [OPTIONS] CONTAINER</code></pre><p><strong>实例</strong><br>查看容器mymysql的文件结构更改。</p><pre><code>runoob@runoob:~$ docker diff mymysqlA /logsA /mysql_dataC /runC /run/mysqldA /run/mysqld/mysqld.pidA /run/mysqld/mysqld.sockC /tmp</code></pre><h2 id="5-镜像仓库"><a href="#5-镜像仓库" class="headerlink" title="5.镜像仓库"></a>5.镜像仓库</h2><h3 id="1-Docker-login-logout-命令"><a href="#1-Docker-login-logout-命令" class="headerlink" title="1).Docker login/logout 命令"></a>1).Docker login/logout 命令</h3><p>docker login : 登陆到一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub<br>docker logout : 登出一个Docker镜像仓库，如果未指定镜像仓库地址，默认为官方仓库 Docker Hub<br><strong>语法</strong></p><pre><code>docker login [OPTIONS] [SERVER]docker logout [OPTIONS] [SERVER]</code></pre><p><strong>OPTIONS说明：</strong><br>-u :登陆的用户名<br>-p :登陆的密码<br><strong>实例</strong><br>登陆到Docker Hub</p><pre><code>docker login -u 用户名 -p 密码</code></pre><p>登出Docker Hub</p><pre><code>docker logout</code></pre><h3 id="2-Docker-pull-命令"><a href="#2-Docker-pull-命令" class="headerlink" title="2).Docker pull 命令"></a>2).Docker pull 命令</h3><p>docker pull : 从镜像仓库中拉取或者更新指定镜像<br><strong>语法</strong></p><pre><code>docker pull [OPTIONS] NAME[:TAG|@DIGEST]</code></pre><p><strong>OPTIONS说明：</strong><br>-a :拉取所有 tagged 镜像<br>–disable-content-trust :忽略镜像的校验,默认开启<br><strong>实例</strong><br>从Docker Hub下载java最新版镜像。</p><pre><code>docker pull java</code></pre><p>从Docker Hub下载REPOSITORY为java的所有镜像。</p><pre><code>docker pull -a java</code></pre><h3 id="3-Docker-push-命令"><a href="#3-Docker-push-命令" class="headerlink" title="3).Docker push 命令"></a>3).Docker push 命令</h3><p>docker push : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库<br><strong>语法</strong></p><pre><code>docker push [OPTIONS] NAME[:TAG]</code></pre><p><strong>OPTIONS说明：</strong><br>–disable-content-trust :忽略镜像的校验,默认开启<br><strong>实例</strong><br>上传本地镜像myapache:v1到镜像仓库中。</p><pre><code>docker push myapache:v1</code></pre><h3 id="4-Docker-search-命令"><a href="#4-Docker-search-命令" class="headerlink" title="4).Docker search 命令"></a>4).Docker search 命令</h3><p>docker search : 从Docker Hub查找镜像<br><strong>语法</strong></p><pre><code>docker search [OPTIONS] TERM</code></pre><p><strong>OPTIONS说明：</strong><br>–automated :只列出 automated build类型的镜像；<br>–no-trunc :显示完整的镜像描述；<br>-s :列出收藏数不小于指定值的镜像。<br><strong>实例</strong><br>从Docker Hub查找所有镜像名包含java，并且收藏数大于10的镜像</p><pre><code>runoob@runoob:~$ docker search -s 10 javaNAME                  DESCRIPTION                           STARS   OFFICIAL   AUTOMATEDjava                  Java is a concurrent, class-based...   1037    [OK]       anapsix/alpine-java   Oracle Java 8 (and 7) with GLIBC ...   115                [OK]develar/java                                                 46                 [OK]isuper/java-oracle    This repository contains all java...   38                 [OK]lwieske/java-8        Oracle Java 8 Container - Full + ...   27                 [OK]nimmis/java-centos    This is docker images of CentOS 7...   13                 [OK]</code></pre><p><a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">6.更多命令</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用容器引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神秘的程序员们  --最懂程序员的漫画</title>
      <link href="2019/06/18/code2048/"/>
      <url>2019/06/18/code2048/</url>
      
        <content type="html"><![CDATA[<p>作为程序员，想必你肯定看过这样一组漫画：简洁的画风，常年驼背对着电脑敲代码的程序员，他表情木讷，嘴里吐槽的内容扎心又有趣，关键是这位程序员发量还很多！</p><p>没错，这就是我们那些年来追过的<strong>《神秘的程序员们》</strong>系列漫画：</p><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1560855281363&di=6b2f3ec409275f528902c02a194ca7c0&imgtype=0&src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20161017%2F86c1b2c90fdf46d8828ae1a9f22d03c5.png" alt="神秘的程序员们"></p><h2 id="关于漫画作者的专访"><a href="#关于漫画作者的专访" class="headerlink" title="关于漫画作者的专访"></a>关于漫画作者的专访</h2><p><a href="https://mp.weixin.qq.com/s/oazcaP7KBVNzO4pRhNdXDw" target="_blank" rel="noopener">不是码农，不会敲代码的她，却最懂程序员！| 人物志</a><br><br></p><h2 id="漫画的最新连载"><a href="#漫画的最新连载" class="headerlink" title="漫画的最新连载"></a>漫画的最新连载</h2><p><a href="https://code2048.com/" target="_blank" rel="noopener">漫画的最新连载</a></p>]]></content>
      
      
      <categories>
          
          <category> 程序人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活点滴 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何安装livere(来必力)到你的hexo博客中</title>
      <link href="2019/06/11/uselivere/"/>
      <url>2019/06/11/uselivere/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo之安装Livere评论插件"><a href="#Hexo之安装Livere评论插件" class="headerlink" title="Hexo之安装Livere评论插件"></a>Hexo之安装Livere评论插件</h1><p>上一篇文章说了如何搭建自己的个人博客之后，那为了方便交流，评论模块也是必不可少的，那这一篇文章就带你快速安装一个评论模块到你的HEXO博客中，这里我使用的是韩国的评论插件：<strong>livere(来必力)</strong></p><h2 id="1-注册激活"><a href="#1-注册激活" class="headerlink" title="1.注册激活"></a>1.注册激活</h2><p>首先先去来必力的官网，注册个账号，登录。<a href="https://www.livere.com" target="_blank" rel="noopener">来必力的官网</a></p><h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2.安装"></a>2.安装</h2><p>点击导航栏的安装，会出现两个版本，一个免费版，一个专业版，专业版需要收费，用哪个看个人需求。<br>点击安装后，第一次安装会要求输入是用网站的一些信息，输入完之后就会生成 来必力City版安装代码以及 data-uid ，或者 进入管理页面-&gt;代码管理-&gt;一般网站，可以查看<br><img src="https://img-blog.csdn.net/20181008115357197?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTIzNjIy/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="安装代码以及 data-uid"></p><h2 id="3-改主题的-config-yml"><a href="#3-改主题的-config-yml" class="headerlink" title="3.改主题的  _config.yml"></a>3.改主题的  _config.yml</h2><p>我的路径是：C:\blog\themes\hexo-theme-matery_config.yml. (你们滴对应)<br>增加如下：</p><pre><code># Livere评论系统Livere:livere_uid:  这里填  City版安装代码中的data-uid</code></pre><h2 id="4-在主题目录下-需要评论地方-加入-来必力City版安装代码"><a href="#4-在主题目录下-需要评论地方-加入-来必力City版安装代码" class="headerlink" title="4.在主题目录下 需要评论地方 加入 来必力City版安装代码"></a>4.在主题目录下 需要评论地方 加入 来必力City版安装代码</h2><p>我需要在每篇文章结束的地方加入评论模块，所以需要在文章详情页面（post.ejs）里添加<strong>来必力City版安装代码</strong>,于是就在 C:\blog\themes\hexo-theme-matery\layout_partial<br>（共用模块文件夹_partial 下 新建 livere.ejs 并把 来必力City版安装代码 放在上面 ，然后在 post.ejs 中对应位置 partial(‘_partial/livere’) 引用即可）</p><h2 id="5-重新部署，大家可以在下面的评论模块看看效果"><a href="#5-重新部署，大家可以在下面的评论模块看看效果" class="headerlink" title="5.重新部署，大家可以在下面的评论模块看看效果"></a>5.重新部署，大家可以在下面的评论模块看看效果</h2><pre><code>hexo cleanhexo ghexo d</code></pre>]]></content>
      
      
      <categories>
          
          <category> 分享创造 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Livere </tag>
            
            <tag> 个人博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thymeleaf -- 一款可以替代jsp的模板引擎</title>
      <link href="2019/06/11/learnthymeleaf/"/>
      <url>2019/06/11/learnthymeleaf/</url>
      
        <content type="html"><![CDATA[<h1 id="一、thymeleaf-是什么"><a href="#一、thymeleaf-是什么" class="headerlink" title="一、thymeleaf 是什么"></a>一、thymeleaf 是什么</h1><p><img src="https://www.thymeleaf.org/images/thymeleaf.png" alt="Thymeleaf 模板引擎 "><br>简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点：</p><p>1.Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</p><p>2.Thymeleaf 开箱即用的特性。它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</p><p>3.Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</p><h1 id="二、thymeleaf-的用法"><a href="#二、thymeleaf-的用法" class="headerlink" title="二、thymeleaf 的用法"></a>二、thymeleaf 的用法</h1><h2 id="1-标准表达式语法"><a href="#1-标准表达式语法" class="headerlink" title="1. 标准表达式语法"></a>1. 标准表达式语法</h2><p>它们分为四类：</p><p>1）.变量表达式<br>2）.选择或星号表达式<br>3）.文字国际化表达式<br>4）.URL表达式</p><h3 id="1）-变量表达式"><a href="#1）-变量表达式" class="headerlink" title="1）.变量表达式"></a>1）.变量表达式</h3><p>变量表达式即OGNL表达式或Spring EL表达式(在Spring术语中也叫model attributes)。如下所示： </p><pre><code>${session.user.name}</code></pre><p>它们将以HTML标签的一个属性来表示：</p><pre><code>&lt;span th:text=&quot;${book.author.name}&quot;&gt;  &lt;li th:each=&quot;book : ${books}&quot;&gt;  </code></pre><h3 id="2）-选择-星号-表达式"><a href="#2）-选择-星号-表达式" class="headerlink" title="2）.选择(星号)表达式"></a>2）.选择(星号)表达式</h3><p>选择表达式很像变量表达式，不过它们用一个预先选择的对象来代替上下文变量容器(map)来执行，选择表达式与变量表达式有一个重要的区别：选择表达式计算的是选定的对象，而不是整个环境变量映射。也就是：只要是没有选择的对象，选择表达式与变量表达式的语法是完全一样的。那什么是选择的对象呢？是一个：th:object对象属性绑定的对象。如下： </p><pre><code>*{customer.name}</code></pre><p>被指定的object由th:object属性定义：</p><pre><code>    &lt;div th:object=&quot;${book}&quot;&gt;        ...        &lt;span th:text=&quot;*{title}&quot;&gt;...&lt;/span&gt;        ...      &lt;/div&gt;  </code></pre><h3 id="3）-文字国际化表达式"><a href="#3）-文字国际化表达式" class="headerlink" title="3）.文字国际化表达式"></a>3）.文字国际化表达式</h3><p>文字国际化表达式允许我们从一个外部文件获取区域文字信息(.properties)，用Key索引Value，还可以提供一组参数(可选)。<br>例如：<br>新建/WEB-INF/templates/home.html，段落</p><pre><code>&lt;p th: text=&quot; #{home. welcome}&quot; &gt;This text will not be show! &lt;/p&gt;</code></pre><p>新建/WEB-INF/templates/home.properties，home.welcome：<br>home.welcome=this messages is from home.properties!</p><p>可以看出，消息表达式通常用于显示页面静态文本，将静态文本维护在properties文件中也方面维护，做国际化等。</p><h3 id="4）-URL表达式"><a href="#4）-URL表达式" class="headerlink" title="4）.URL表达式"></a>4）.URL表达式</h3><p>URL表达式指的是把一个有用的上下文或回话信息添加到URL，这个过程经常被叫做URL重写。<br><code>@{/order/list}</code><br>URL还可以设置参数：<br><code>@{/order/details(id=${orderId})}</code><br>相对路径：<br><code>@{../documents/report}</code></p><p>让我们看这些表达式：</p><pre><code>    &lt;form th:action=&quot;@{/createOrder}&quot;&gt;      &lt;a href=&quot;main.html&quot; th:href=&quot;@{/main}&quot;&gt;</code></pre><h3 id="5）-变量表达式和星号表达有什么区别吗？"><a href="#5）-变量表达式和星号表达有什么区别吗？" class="headerlink" title="5）.变量表达式和星号表达有什么区别吗？"></a>5）.变量表达式和星号表达有什么区别吗？</h3><p>如果不考虑上下文的情况下，两者没有区别；星号语法评估在选定对象上表达，而不是整个上下文<br>什么是选定对象？就是父标签的值，如下：</p><pre><code>  &lt;div th:object=&quot;${session.user}&quot;&gt;    &lt;p&gt;Name: &lt;span th:text=&quot;*{firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;    &lt;p&gt;Surname: &lt;span th:text=&quot;*{lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;    &lt;p&gt;Nationality: &lt;span th:text=&quot;*{nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;  &lt;/div&gt;</code></pre><p>这是完全等价于：</p><pre><code>&lt;div th:object=&quot;${session.user}&quot;&gt;      &lt;p&gt;Name: &lt;span th:text=&quot;${session.user.firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;      &lt;p&gt;Surname: &lt;span th:text=&quot;${session.user.lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;      &lt;p&gt;Nationality: &lt;span th:text=&quot;${session.user.nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;  &lt;/div&gt;</code></pre><p>当然，美元符号和星号语法可以混合使用：</p><pre><code>  &lt;div th:object=&quot;${session.user}&quot;&gt;      &lt;p&gt;Name: &lt;span th:text=&quot;*{firstName}&quot;&gt;Sebastian&lt;/span&gt;.&lt;/p&gt;      &lt;p&gt;Surname: &lt;span th:text=&quot;${session.user.lastName}&quot;&gt;Pepper&lt;/span&gt;.&lt;/p&gt;      &lt;p&gt;Nationality: &lt;span th:text=&quot;*{nationality}&quot;&gt;Saturn&lt;/span&gt;.&lt;/p&gt;  &lt;/div&gt;</code></pre><h2 id="2-表达式支持的语法"><a href="#2-表达式支持的语法" class="headerlink" title="2. 表达式支持的语法"></a>2. 表达式支持的语法</h2><h3 id="1-字面（Literals）"><a href="#1-字面（Literals）" class="headerlink" title="1).字面（Literals）"></a>1).字面（Literals）</h3><p>文本文字（Text literals）: ‘one text’, ‘Another one!’,…<br>数字文本（Number literals）: 0, 34, 3.0, 12.3,…<br>布尔文本（Boolean literals）: true, false<br>空（Null literal）: null<br>文字标记（Literal tokens）: one, sometext, main,…</p><h3 id="2-文本操作（Text-operations）"><a href="#2-文本操作（Text-operations）" class="headerlink" title="2).文本操作（Text operations）"></a>2).文本操作（Text operations）</h3><p>字符串连接(String concatenation): +<br>文本替换（Literal substitutions）: |The name is ${name}|</p><h3 id="3-算术运算（Arithmetic-operations）"><a href="#3-算术运算（Arithmetic-operations）" class="headerlink" title="3).算术运算（Arithmetic operations）"></a>3).算术运算（Arithmetic operations）</h3><p>二元运算符（Binary operators）: +, -, *, /, %<br>减号（单目运算符）Minus sign (unary operator): -</p><h3 id="4-布尔操作（Boolean-operations）"><a href="#4-布尔操作（Boolean-operations）" class="headerlink" title="4).布尔操作（Boolean operations）"></a>4).布尔操作（Boolean operations）</h3><p>二元运算符（Binary operators）:and, or<br>布尔否定（一元运算符）Boolean negation (unary operator):!, not</p><h3 id="5-比较和等价-Comparisons-and-equality"><a href="#5-比较和等价-Comparisons-and-equality" class="headerlink" title="5).比较和等价(Comparisons and equality)"></a>5).比较和等价(Comparisons and equality)</h3><p>比较（Comparators）: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le)<br>等值运算符（Equality operators）:==, != (eq, ne)</p><h3 id="6-条件运算符（Conditional-operators）"><a href="#6-条件运算符（Conditional-operators）" class="headerlink" title="6).条件运算符（Conditional operators）"></a>6).条件运算符（Conditional operators）</h3><p>If-then: (if) ? (then)<br>If-then-else: (if) ? (then) : (else)<br>Default: (value) ?: (defaultvalue)</p><p><strong>所有这些特征可以被组合并嵌套：</strong></p><pre><code>&#39;User is of type &#39; + (${user.isAdmin()} ? &#39;Administrator&#39; : (${user.type} ?: &#39;Unknown&#39;))</code></pre><h2 id="3-常用的Th标签"><a href="#3-常用的Th标签" class="headerlink" title="3. 常用的Th标签"></a>3. 常用的Th标签</h2><table><thead><tr><th align="center">关键字</th><th align="center">功能介绍</th><th align="center">案例</th></tr></thead><tbody><tr><td align="center">th:id</td><td align="center">替换id</td><td align="center"><code>&lt;input th:id=&quot;&#39;xxx&#39; + ${collect.id}&quot;/&gt;</code></td></tr><tr><td align="center">th:text</td><td align="center">文本替换</td><td align="center"><code>&lt;p th:text=&quot;${collect.description}&quot;&gt;description&lt;/p&gt;</code></td></tr><tr><td align="center">th:utext</td><td align="center">支持html的文本替换</td><td align="center"><code>&lt;p th:utext=&quot;${htmlcontent}&quot;&gt;conten&lt;/p&gt;</code></td></tr><tr><td align="center">th:object</td><td align="center">替换对象</td><td align="center"><code>&lt;div th:object=&quot;${session.user}&quot;&gt;</code></td></tr><tr><td align="center">th:value</td><td align="center">属性赋值</td><td align="center"><code>&lt;input th:value=&quot;${user.name}&quot; /&gt;</code></td></tr><tr><td align="center">th:with</td><td align="center">变量赋值运算</td><td align="center"><code>&lt;div th:with=&quot;isEven=${prodStat.count}%2==0&quot;&gt;&lt;/div&gt;</code></td></tr><tr><td align="center">th:style</td><td align="center">设置样式</td><td align="center"><code>th:style=&quot;&#39;display:&#39; + @{(${sitrue} ? &#39;none&#39; : &#39;inline-block&#39;)} + &#39;&#39;&quot;</code></td></tr><tr><td align="center">th:onclick</td><td align="center">点击事件</td><td align="center"><code>th:onclick=&quot;&#39;getCollect()&#39;&quot;</code></td></tr><tr><td align="center">th:each</td><td align="center">属性赋值</td><td align="center"><code>tr th:each=&quot;user,userStat:${users}&quot;&gt;</code></td></tr><tr><td align="center">th:if</td><td align="center">判断条件</td><td align="center"><code>&lt;a th:if=&quot;${userId == collect.userId}&quot; &gt;</code></td></tr><tr><td align="center">th:unless</td><td align="center">和th:if判断相反</td><td align="center"><code>&lt;a th:href=&quot;@{/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt;</code></td></tr><tr><td align="center">th:href</td><td align="center">链接地址</td><td align="center"><code>&lt;a th:href=&quot;@{/login}&quot; th:unless=${session.user != null}&gt;Login&lt;/a&gt; /&gt;</code></td></tr><tr><td align="center">th:switch</td><td align="center">多路选择配合th:case 使用</td><td align="center"><code>&lt;div th:switch=&quot;${user.role}&quot;&gt;</code></td></tr><tr><td align="center">th:case</td><td align="center">th:switch的一个分支</td><td align="center"><code>&lt;p th:case=&quot;&#39;admin&#39;&quot;&gt;User is an administrator&lt;/p&gt;</code></td></tr><tr><td align="center">th:fragment</td><td align="center">布局标签，定义一个代码片段，方便其它地方引用</td><td align="center"><code>&lt;div th:fragment=&quot;alert&quot;&gt;</code></td></tr><tr><td align="center">th:include</td><td align="center">布局标签，替换内容到引入的文件</td><td align="center"><code>&lt;head th:include=&quot;layout :: htmlhead&quot; th:with=&quot;title=&#39;xx&#39;&quot;&gt;&lt;/head&gt; /&gt;</code></td></tr><tr><td align="center">th:replace</td><td align="center">布局标签，替换整个标签到引入的文件</td><td align="center"><code>&lt;div th:replace=&quot;fragments/header :: title&quot;&gt;&lt;/div&gt;</code></td></tr><tr><td align="center">th:selected</td><td align="center">selected选择框 选中</td><td align="center"><code>th:selected=&quot;(${xxx.id} == ${configObj.dd})&quot;</code></td></tr><tr><td align="center">th:src</td><td align="center">图片类地址引入</td><td align="center"><code>&lt;img class=&quot;img-responsive&quot; alt=&quot;App Logo&quot; th:src=&quot;@{/img/logo.png}&quot; /&gt;</code></td></tr><tr><td align="center">th:inline</td><td align="center">定义js脚本可以使用变量</td><td align="center"><code>&lt;script type=&quot;text/javascript&quot; th:inline=&quot;javascript&quot;&gt;</code></td></tr><tr><td align="center">th:action</td><td align="center">表单提交的地址</td><td align="center"><code>&lt;form action=&quot;subscribe.html&quot; th:action=&quot;@{/subscribe}&quot;&gt;</code></td></tr><tr><td align="center">th:remove</td><td align="center">删除某个属性</td><td align="center"><code>&lt;tr th:remove=&quot;all&quot;&gt; 1.all:删除包含标签和所有的孩子。2.body:不包含标记删除,但删除其所有的孩子。3.tag:包含标记的删除,但不删除它的孩子。4.all-but-first:删除所有包含标签的孩子,除了第一个。5.none:什么也不做。这个值是有用的动态评估。</code></td></tr><tr><td align="center">th:attr</td><td align="center">设置标签属性，多个属性可以用逗号分隔</td><td align="center"><code>比如 th:attr=&quot;src=@{/image/aa.jpg},title=#{logo}&quot;，此标签不太优雅，一般用的比较少。</code></td></tr></tbody></table><br>**还有非常多的标签，这里只列出最常用的几个,由于一个标签内可以包含多个th:x属性，其生效的优先级顺序为: **<br>**include,each,if/unless/switch/case,with,attr/attrprepend/attrappend,value/href,src ,etc,text/utext,fragment,remove。**<h2 id="4-几种常用的用法"><a href="#4-几种常用的用法" class="headerlink" title="4. 几种常用的用法"></a>4. 几种常用的用法</h2><h3 id="（1）赋值、字符串拼接"><a href="#（1）赋值、字符串拼接" class="headerlink" title="（1）赋值、字符串拼接"></a>（1）赋值、字符串拼接</h3><pre><code> &lt;p  th:text=&quot;${collect.description}&quot;&gt;description&lt;/p&gt; &lt;span th:text=&quot;&#39;Welcome to our application, &#39; + ${user.name} + &#39;!&#39;&quot;&gt;</code></pre><p>字符串拼接还有另外一种简洁的写法</p><pre><code>&lt;span th:text=&quot;|Welcome to our application, ${user.name}!|&quot;&gt;</code></pre><h3 id="（2）条件判断-If-Unless"><a href="#（2）条件判断-If-Unless" class="headerlink" title="（2）条件判断 If/Unless"></a>（2）条件判断 If/Unless</h3><p>Thymeleaf中使用th:if和th:unless属性进行条件判断，下面的例子中，<a>标签只有在th:if中条件成立时才显示：</a></p><pre><code>&lt;a th:if=&quot;${myself==&#39;yes&#39;}&quot; &gt; &lt;/i&gt; &lt;/a&gt;&lt;a th:unless=${session.user != null} th:href=&quot;@{/login}&quot; &gt;Login&lt;/a&gt;</code></pre><p>th:unless于th:if恰好相反，只有表达式中的条件不成立，才会显示其内容。</p><p>也可以使用 (if) ? (then) : (else) 这种语法来判断显示的内容</p><h3 id="（3）for-循环"><a href="#（3）for-循环" class="headerlink" title="（3）for 循环"></a>（3）for 循环</h3><pre><code>  &lt;tr  th:each=&quot;collect,iterStat : ${collects}&quot;&gt;      &lt;th scope=&quot;row&quot; th:text=&quot;${collect.id}&quot;&gt;1&lt;/th&gt;     &lt;td &gt;        &lt;img th:src=&quot;${collect.webLogo}&quot;/&gt;     &lt;/td&gt;     &lt;td th:text=&quot;${collect.url}&quot;&gt;Mark&lt;/td&gt;     &lt;td th:text=&quot;${collect.title}&quot;&gt;Otto&lt;/td&gt;     &lt;td th:text=&quot;${collect.description}&quot;&gt;@mdo&lt;/td&gt;     &lt;td th:text=&quot;${terStat.index}&quot;&gt;index&lt;/td&gt; &lt;/tr&gt;</code></pre><p><strong>iterStat称作状态变量，属性有：</strong><br>index:当前迭代对象的index（从0开始计算）<br>count: 当前迭代对象的index(从1开始计算)<br>size:被迭代对象的大小<br>current:当前迭代变量<br>even/odd:布尔值，当前循环是否是偶数/奇数（从0开始计算）<br>first:布尔值，当前循环是否是第一个<br>last:布尔值，当前循环是否是最后一个</p><h3 id="（4）URL"><a href="#（4）URL" class="headerlink" title="（4）URL"></a>（4）URL</h3><p>URL在Web应用模板中占据着十分重要的地位，需要特别注意的是Thymeleaf对于URL的处理是通过语法@{…}来处理的。<br>如果需要Thymeleaf对URL进行渲染，那么务必使用th:href，th:src等属性，下面是一个例子</p><pre><code>&lt;!-- Will produce &#39;http://localhost:8080/standard/unread&#39; (plus rewriting) --&gt; &lt;a  th:href=&quot;@{/standard/{type}(type=${type})}&quot;&gt;view&lt;/a&gt;&lt;!-- Will produce &#39;/gtvg/order/3/details&#39; (plus rewriting) --&gt;&lt;a href=&quot;details.html&quot; th:href=&quot;@{/order/{orderId}/details(orderId=${o.id})}&quot;&gt;view&lt;/a&gt;</code></pre><p>设置背景</p><pre><code>&lt;div th:style=&quot;&#39;background:url(&#39; + @{/&lt;path-to-image&gt;} + &#39;);&#39;&quot;&gt;&lt;/div&gt;</code></pre><p>根据属性值改变背景</p><pre><code> &lt;div class=&quot;media-object resource-card-image&quot;  th:style=&quot;&#39;background:url(&#39; + @{(${collect.webLogo}==&#39;&#39; ? &#39;img/favicon.png&#39; : ${collect.webLogo})} + &#39;)&#39;&quot; &gt;&lt;/div&gt;</code></pre><p>几点说明：<br>上例中URL最后的(orderId=${o.id}) 表示将括号内的内容作为URL参数处理，该语法避免使用字符串拼接，大大提高了可读性<br>@{…}表达式中可以通过{orderId}访问Context中的orderId变量<br>@{/order}是Context相关的相对路径，在渲染时会自动添加上当前Web应用的Context名字，假设context名字为app，那么结果应该是/app/order</p><h3 id="（5）内联js"><a href="#（5）内联js" class="headerlink" title="（5）内联js"></a>（5）内联js</h3><p>内联文本：[[…]]内联文本的表示方式，使用时，必须先用th:inline=”text/javascript/none”激活，th:inline可以在父级标签内使用，甚至作为body的标签。内联文本尽管比th:text的代码少，不利于原型显示。</p><pre><code>&lt;script th:inline=&quot;javascript&quot;&gt;/*&lt;![CDATA[*/...var username = /*[[${sesion.user.name}]]*/ &#39;Sebastian&#39;;var size = /*[[${size}]]*/ 0;.../*]]&gt;*/&lt;/script&gt;</code></pre><p>js附加代码：</p><pre><code>/*[+var msg = &#39;This is a working application&#39;;+]*/</code></pre><p>js移除代码：</p><pre><code>/*[- */var msg = &#39;This is a non-working template&#39;;/* -]*/</code></pre><h3 id="（6）内嵌变量"><a href="#（6）内嵌变量" class="headerlink" title="（6）内嵌变量"></a>（6）内嵌变量</h3><p>为了模板更加易用，Thymeleaf还提供了一系列Utility对象（内置于Context中），可以通过#直接访问：<br>dates ： java.util.Date的功能方法类。<br>calendars : 类似#dates，面向java.util.Calendar<br>numbers : 格式化数字的功能方法类<br>strings : 字符串对象的功能类，contains,startWiths,prepending/appending等等。<br>objects: 对objects的功能类操作。<br>bools: 对布尔值求值的功能方法。<br>arrays：对数组的功能类方法。<br>lists: 对lists功能类方法<br>sets<br>maps<br>…下面用一段代码来举例一些常用的方法：<br><strong>dates</strong></p><pre><code>/* * Format date with the specified pattern * Also works with arrays, lists or sets */${#dates.format(date, &#39;dd/MMM/yyyy HH:mm&#39;)}${#dates.arrayFormat(datesArray, &#39;dd/MMM/yyyy HH:mm&#39;)}${#dates.listFormat(datesList, &#39;dd/MMM/yyyy HH:mm&#39;)}${#dates.setFormat(datesSet, &#39;dd/MMM/yyyy HH:mm&#39;)}/* * Create a date (java.util.Date) object for the current date and time */${#dates.createNow()}/* * Create a date (java.util.Date) object for the current date (time set to 00:00) */${#dates.createToday()}</code></pre><p><strong>strings</strong></p><pre><code>/* * Check whether a String is empty (or null). Performs a trim() operation before check * Also works with arrays, lists or sets */${#strings.isEmpty(name)}${#strings.arrayIsEmpty(nameArr)}${#strings.listIsEmpty(nameList)}${#strings.setIsEmpty(nameSet)}/* * Check whether a String starts or ends with a fragment * Also works with arrays, lists or sets */${#strings.startsWith(name,&#39;Don&#39;)}                  // also array*, list* and set*${#strings.endsWith(name,endingFragment)}           // also array*, list* and set*/* * Compute length * Also works with arrays, lists or sets */${#strings.length(str)}/* * Null-safe comparison and concatenation */${#strings.equals(str)}${#strings.equalsIgnoreCase(str)}${#strings.concat(str)}${#strings.concatReplaceNulls(str)}/* * Random */${#strings.randomAlphanumeric(count)}</code></pre><h2 id="5-使用thymeleaf布局"><a href="#5-使用thymeleaf布局" class="headerlink" title="5. 使用thymeleaf布局"></a>5. 使用thymeleaf布局</h2><p>使用thymeleaf布局非常的方便<br>定义代码片段</p><pre><code>&lt;footer th:fragment=&quot;copy&quot;&gt; &amp;copy; 2016&lt;/footer&gt;</code></pre><p>在页面任何地方引入：</p><pre><code>&lt;body&gt;   &lt;div th:include=&quot;footer :: copy&quot;&gt;&lt;/div&gt;  &lt;div th:replace=&quot;footer :: copy&quot;&gt;&lt;/div&gt; &lt;/body&gt;</code></pre><p>th:include 和 th:replace区别，include只是加载，replace是替换</p><p>返回的HTML如下：</p><pre><code>&lt;body&gt;    &lt;div&gt; &amp;copy; 2016 &lt;/div&gt;   &lt;footer&gt;&amp;copy; 2016 &lt;/footer&gt; &lt;/body&gt;</code></pre><p>下面是一个常用的后台页面布局，将整个页面分为头部，尾部、菜单栏、隐藏栏，点击菜单只改变content区域的页面</p><pre><code>&lt;body class=&quot;layout-fixed&quot;&gt;  &lt;div th:fragment=&quot;navbar&quot;  class=&quot;wrapper&quot;  role=&quot;navigation&quot;&gt;    &lt;div th:replace=&quot;fragments/header :: header&quot;&gt;Header&lt;/div&gt;    &lt;div th:replace=&quot;fragments/left :: left&quot;&gt;left&lt;/div&gt;    &lt;div th:replace=&quot;fragments/sidebar :: sidebar&quot;&gt;sidebar&lt;/div&gt;    &lt;div layout:fragment=&quot;content&quot; id=&quot;content&quot; &gt;&lt;/div&gt;    &lt;div th:replace=&quot;fragments/footer :: footer&quot;&gt;footer&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;</code></pre><p>任何页面想使用这样的布局值只需要替换中见的 content模块即可</p><pre><code> &lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; layout:decorator=&quot;layout&quot;&gt;   &lt;body&gt;      &lt;section layout:fragment=&quot;content&quot;&gt;    ...</code></pre><p>也可以在引用模版的时候传参</p><pre><code>&lt;head th:include=&quot;layout :: htmlhead&quot; th:with=&quot;title=&#39;Hello&#39;&quot;&gt;&lt;/head&gt;</code></pre><p>layout 是文件地址，如果有文件夹可以这样写 fileName/layout:htmlhead<br>htmlhead 是指定义的代码片段 如 th:fragment=”copy”</p>]]></content>
      
      
      <categories>
          
          <category> 后端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模板引擎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打造一个属于自己的个人博客（使用HEXO搭建，配合github主页部署）</title>
      <link href="2019/06/05/howtocreateblog/"/>
      <url>2019/06/05/howtocreateblog/</url>
      
        <content type="html"><![CDATA[<h2 id="一、打造初心"><a href="#一、打造初心" class="headerlink" title="一、打造初心"></a>一、打造初心</h2><p>现在市面上的博客很多，如CSDN，博客园，简书等平台，可以直接在上面发表，用户交互做的好，写的文章百度也能搜索的到。缺点是比较不自由，会受到平台的各种限制和恶心的广告。</p><p>而自己购买域名和服务器，搭建博客的成本实在是太高了，不光是说这些购买成本，单单是花力气去自己搭这么一个网站，还要定期的维护它，对于我们大多数人来说，实在是没有这样的精力和时间。</p><p>那么就有第三种选择，直接在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。</p><h2 id="二、Hexo简介"><a href="#二、Hexo简介" class="headerlink" title="二、Hexo简介"></a>二、Hexo简介</h2><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><p>教程分三个部分，</p><p><strong>第一部分：hexo的初级搭建还有部署到github page上，以及个人域名的绑定。</strong><br><br><strong>第二部分：hexo的基本配置，更换主题，实现多终端工作，以及在coding page部署实现国内外分流。</strong><br><br><strong>第三部分：hexo添加各种功能，包括搜索的SEO，阅读量统计，访问量统计和评论系统等。</strong> </p><h2 id="三、第一部分"><a href="#三、第一部分" class="headerlink" title="三、第一部分"></a>三、第一部分</h2><p>hexo的初级搭建还有部署到github page上，以及个人域名的绑定。</p><h3 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h3><p><strong>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入hexo官网进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</strong></p><h4 id="Hexo搭建步骤"><a href="#Hexo搭建步骤" class="headerlink" title="Hexo搭建步骤"></a>Hexo搭建步骤</h4><ul><li>安装Git</li><li>安装Node.js</li><li>安装Hexo</li><li>GitHub创建个人仓库</li><li>生成SSH添加到GitHub</li><li>将hexo部署到GitHub</li><li>设置个人域名</li><li>发布文章</li></ul><ol><li>安装Git<br>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以了解一下。Git教程</li></ol><p>windows：到git官网上下载,Download git,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。</p><p>linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码<br><code>sudo apt-get install git</code></p><p>安装好后，用<code>git --version</code> 来查看一下版本</p><ol start="2"><li>安装nodejs<br>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。</li></ol><p>windows：nodejs选择LTS版本就行了。<br>安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量），没有的话你就自由发挥吧。</p><p>linux：</p><pre><code>sudo apt-get install nodejssudo apt-get install npm</code></pre><p>安装完后，打开命令行</p><pre><code>node -vnpm -v</code></pre><p>检查一下有没有安装成功</p><p>顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。</p><ol start="3"><li>安装hexo<br>前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后cd到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。<br>输入命令<pre><code>npm install -g hexo-cli</code></pre></li></ol><p>依旧用hexo -v查看一下版本</p><p>至此就全部安装完了。</p><p>接下来初始化一下hexo<br><code>hexo init myblog</code></p><p>这个myblog可以自己取什么名字都行，然后 cd myblog //进入这个myblog文件夹<br><code>npm install</code></p><p>新建完成后，指定文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li></ul><p>** _config.yml: 博客的配置文件**</p><pre><code>hexo ghexo server</code></pre><p>打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。</p><p>使用ctrl+c可以把服务关掉。</p><ol start="4"><li>GitHub创建个人仓库<br>首先，你先要有一个GitHub账户，去注册一个吧。</li></ol><p>注册完登录后，在GitHub.com中看到一个New repository，新建仓库</p><p>创建一个和你用户名相同的仓库，后面加.github.io，只有这样，将来要部署到GitHub page的时候，才会被识别，也就是xxxx.github.io，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。</p><p>点击create repository。</p><ol start="5"><li>生成SSH添加到GitHub<br>回到你的git bash中，<pre><code>git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;</code></pre></li></ol><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。</p><p>可以用以下两条，检查一下你有没有输对</p><pre><code>git config user.namegit config user.email</code></pre><p>然后创建SSH,一路回车</p><pre><code>ssh-keygen -t rsa -C &quot;youremail&quot;</code></pre><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。</p><p>ssh，简单来讲，就是一个秘钥，其中，id_rsa是你这台电脑的私人秘钥，不能给别人看的，id_rsa.pub是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p><p>而后在GitHub的setting中，找到SSH keys的设置选项，点击New SSH key<br>把你的id_rsa.pub里面的信息复制进去。</p><p>在gitbash中，查看是否成功<br><code>ssh -T git@github.com</code></p><ol start="6"><li>将hexo部署到GitHub<br>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 _config.yml，翻到最后，修改为<br>YourgithubName就是你的GitHub账户<pre><code>deploy:type: gitrepo: https://github.com/YourgithubName/YourgithubName.github.io.gitbranch: master</code></pre></li></ol><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。<br><code>npm install hexo-deployer-git --save</code></p><p>然后</p><pre><code>hexo cleanhexo generatehexo deploy</code></pre><p>其中 hexo clean清除了你之前生成的东西，也可以不加。<br>hexo generate 顾名思义，生成静态文章，可以用 hexo g缩写<br>hexo deploy 部署文章，可以用hexo d缩写</p><p>注意deploy时可能要你输入username和password。</p><p>得到下图就说明部署成功了，过一会儿就可以在<a href="http://yourname.github.io" target="_blank" rel="noopener">http://yourname.github.io</a> 这个网站看到你的博客了！！</p><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2749245970,910829670&fm=11&gp=0.jpg" alt="部署成功，访问的hexo博客界面"></p><ol start="7"><li>设置个人域名<br>现在你的个人网站的地址是 yourname.github.io，如果觉得这个网址逼格不太够，这就需要你设置个人域名了。但是需要花钱。</li></ol><p>注册一个阿里云账户,在阿里云上买一个域名，我买的是 fangzh.top，各个后缀的价格不太一样，比如最广泛的.com就比较贵，看个人喜好咯。</p><p>你需要先去进行实名认证,然后在域名控制台中，看到你购买的域名。</p><p>点解析进去，添加解析。<br>其中，192.30.252.153 和 192.30.252.154 是GitHub的服务器地址。<br>注意，解析线路选择默认，不要像我一样选境外。这个境外是后面来做国内外分流用的,在后面的博客中会讲到。记得现在选择默认！！</p><p>登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名fangzh.top</p><p>然后在你的博客文件source中创建一个名为CNAME文件，不要后缀。写上你的域名。</p><p>最后，在gitbash中，输入</p><pre><code>hexo cleanhexo ghexo d</code></pre><p>过不了多久，再打开你的浏览器，输入你自己的域名，就可以看到搭建的网站啦！</p><p>接下来你就可以正式开始写文章了。<br><code>hexo new newpapername</code></p><p>然后在source/_post中打开markdown文件，就可以开始编辑了。当你写完的时候，再</p><pre><code>hexo cleanhexo ghexo d</code></pre><p>就可以看到更新了。<br><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2749245970,910829670&fm=11&gp=0.jpg" alt="更新后的网站"></p><h2 id="四、第二部分"><a href="#四、第二部分" class="headerlink" title="四、第二部分"></a>四、第二部分</h2><p>hexo的基本配置，更换主题，实现多终端工作，以及在coding page部署实现国内外分流。</p><ol><li>hexo基本配置<br>在文件根目录下的_config.yml，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考官方的配置描述。</li></ol><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">layout</td><td align="center">布局</td></tr><tr><td align="center">title</td><td align="center">标题</td></tr><tr><td align="center">date</td><td align="center">建立日期</td></tr><tr><td align="center">updated</td><td align="center">更新日期</td></tr><tr><td align="center">comments</td><td align="center">开启文章的评论功能</td></tr><tr><td align="center">tags</td><td align="center">标签（不适用于分页）</td></tr><tr><td align="center">categories</td><td align="center">分类（不适用于分页）</td></tr><tr><td align="center">permalink</td><td align="center">覆盖文章网址</td></tr></tbody></table><p>其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。</p><p>这里直接填写中文会出现中文乱码的现象，解决方法：将 language 设置为 zh-Hans  并使用UTF-8的编码保存。</p><h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">post</td><td align="center">source/_posts</td></tr><tr><td align="center">page</td><td align="center">source</td></tr><tr><td align="center">draft</td><td align="center">source/_drafts</td></tr></tbody></table><p>在这里，你需要把url改成你的网站域名。</p><p>permalink，也就是你生成某个文章时的那个链接格式。</p><p>比如我新建一个文章叫temp.md，那么这个时候他自动生成的地址就是<a href="http://yoursite.com/2018/09/05/temp。" target="_blank" rel="noopener">http://yoursite.com/2018/09/05/temp。</a></p><p>以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找永久链接 。<br>再往下翻，中间这些都默认就好了。</p><p>theme就是选择什么主题，也就是在theme这个文件夹下，在官网上有很多个主题，默认给你安装的是lanscape这个主题。当你需要更换主题时，在官网上下载，把主题的文件放在theme文件夹下，再修改这个参数就可以了。</p><p>接下来这个deploy就是网站的部署的，repo就是仓库(Repository)的简写。branch选择仓库的哪个分支。这个在之前进行github page部署的时候已经修改过了，不再赘述。而这个在后面进行双平台部署的时候会再次用到。</p><ol start="2"><li>hexo的基本指令<pre><code>init$ hexo init [folder]</code></pre></li></ol><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p><pre><code>new$ hexo new [layout] &lt;title&gt;</code></pre><p>新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p><pre><code>$ hexo new &quot;post title with whitespace&quot;generate$ hexo generate</code></pre><p>生成静态文件。<br>选项 描述<br>-d, –deploy 文件生成后立即部署网站<br>-w, –watch 监视文件变动<br>该命令可以简写为</p><pre><code>$ hexo gpublish$ hexo publish [layout] &lt;filename&gt;</code></pre><p>发表草稿。</p><pre><code>server$ hexo server</code></pre><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/。" target="_blank" rel="noopener">http://localhost:4000/。</a><br>选项 描述<br>-p, –port 重设端口<br>-s, –static 只使用静态文件<br>-l, –log 启动日记记录，使用覆盖记录格式</p><pre><code>deploy$ hexo deploy</code></pre><p>部署网站。<br>参数 描述<br>-g, –generate 部署之前预先生成静态文件<br>该命令可以简写为：</p><pre><code>$ hexo d</code></pre><pre><code>render$ hexo render &lt;file1&gt; [file2] ...</code></pre><p>渲染文件。<br>参数 描述<br>-o, –output 设置输出路径</p><pre><code>migrate$ hexo migrate &lt;type&gt;</code></pre><p>从其他博客系统 迁移内容。</p><pre><code>clean$ hexo clean</code></pre><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。<br>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><pre><code>list$ hexo list &lt;type&gt;</code></pre><p>列出网站资料。</p><pre><code>version$ hexo version</code></pre><p>显示 Hexo 版本。</p><p>选项<br>安全模式</p><pre><code>$ hexo --safe</code></pre><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><p>调试模式</p><pre><code>$ hexo --debug</code></pre><p>在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。</p><p>简洁模式</p><pre><code>$ hexo --silent</code></pre><p>隐藏终端信息。</p><p>自定义配置文件的路径</p><pre><code>$ hexo --config custom.yml</code></pre><p>自定义配置文件的路径，执行后将不再使用 _config.yml。</p><p>显示草稿</p><pre><code>$ hexo --draft</code></pre><p>显示 source/_drafts 文件夹中的草稿文章。</p><p>自定义 CWD</p><pre><code>$ hexo --cwd /path/to/cwd</code></pre><p>自定义当前工作目录（Current working directory）的路径。</p><h2 id="五、第三部分"><a href="#五、第三部分" class="headerlink" title="五、第三部分"></a>五、第三部分</h2><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><p>到这一步，如果你觉得默认的landscape主题不好看，那么可以在官网的主题中，选择你喜欢的一个主题进行修改就可以啦。<a href="https://hexo.io/themes/" target="_blank" rel="noopener">点这里</a><br><br><br>直接在github链接上下载下来，然后放到theme文件夹下就行了，然后再在刚才说的配置文件中把theme换成那个主题文件夹的名字，它就会自动在theme文件夹中搜索你配置的主题。<br><br><br>而后进入hueman这个文件夹，可以看到里面也有一个配置文件_config.xml，貌似它默认是_config.xml.example，把它复制一份，重命名为_config.xml就可以了。这个配置文件是修改你整个主题的配置文件。</p><h2 id="六、特别鸣谢"><a href="#六、特别鸣谢" class="headerlink" title="六、特别鸣谢"></a>六、特别鸣谢</h2><p>由于时间问题，hexo后面集成的很多功能，就不慢慢的深究下去，按照以上步骤，博客基本上就已经搭建起来，并可以正常的写文章了。<br><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">本文参考了 zjufangzh的csdn原创文章：hexo史上最全搭建教程，更多教程可直接访问原文</a><br><a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">博客的主题是用了闪烁之狐的hexo-theme-matery</a></p>]]></content>
      
      
      <categories>
          
          <category> 分享创造 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人博客 </tag>
            
            <tag> HEXO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown常用语法，让你快速上手MarkDown</title>
      <link href="2019/05/31/markdown/"/>
      <url>2019/05/31/markdown/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><strong>Markdown是一种可以使用普通文本编辑器编写的标记语言</strong>，通过简单的标记语法，它可以使普通文本内容具有一定的格式。<br><br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1559304132969&di=6eefc352c0a71b2ec375f01ec27252ea&imgtype=0&src=http%3A%2F%2Fwww.th7.cn%2Fd%2Ffile%2Fp%2F2016%2F04%2F17%2Faf9f05c290c3ba56ea53ddc978c557ed.jpg" alt="Markdown"></p><h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p>[TOC]</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>正文</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul><li>无序列表1 【减号+空格】</li><li>无序列表2<br>- 无序列表1 【减号+空格】<br>- 无序列表2</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol><li>有序列表1</li><li>有序列表2</li><li>不管前面序号是否错误，依次排列</li></ol><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote><p>我是引用来的 【&gt;+空格】<br>我是引用来的</p></blockquote><p>&gt; 我是一条引用</p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><pre class=" language-java"><code class="language-java">  代码段</code></pre><p>``` java<br>  代码段<br>```</p><h3 id="制作待办事项-to-do-list"><a href="#制作待办事项-to-do-list" class="headerlink" title="制作待办事项 to do list"></a>制作待办事项 to do list</h3><ul><li><input checked disabled type="checkbox"> bbs</li><li><input disabled type="checkbox"> aaa 维护</li></ul><p>- [x] bbs<br>- [ ] aaa 维护</p><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><pre class=" language-mermaid"><code class="language-mermaid">    graph TD        A --> B</code></pre><h3 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h3><p>两个或-代表加粗，一个或-代表斜体，~~代表删除。</p><p><strong>加粗文本</strong><br><em>斜体</em><br><del>删除线</del><br>==高亮==<br><code>底纹</code></p><p>*<em>加粗文本**\</em>斜体*~<del>删除线</del><br>==高亮==<br>`底纹`</p><h3 id="字体的上下标"><a href="#字体的上下标" class="headerlink" title="字体的上下标"></a>字体的上下标</h3><p>这是^上标文字^<br>这是<del>下标文字</del></p><p>这是^上标文字^<br>这是~下标文字~</p><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><p>图片：<img src alt> <img src="%E9%93%BE%E6%8E%A5%E7%9A%84%E5%9C%B0%E5%9D%80" alt="图片描述(可忽略)"><br>链接：<a href></a> <a href="链接的地址">链接描述</a></p><p>This is <a href="http://example.com/" title="Title" target="_blank" rel="noopener">an example</a> inline link.<br><a href="http://example.net/" target="_blank" rel="noopener">This link</a> has no title attribute.</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><blockquote><p>表格对齐格式<br>居左：:—-<br>居中：:—-:或—–<br>居右：—-:</p></blockquote><table><thead><tr><th align="left">标题</th><th align="center">标题</th><th align="right">标题</th></tr></thead><tbody><tr><td align="left">居左文本</td><td align="center">居中文本</td><td align="right">居右文本</td></tr></tbody></table><p>|标题|标题|标题  |<br>|:—|:—:|—:|<br>|居左文本|居中文本|居右文本|</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><hr><hr><hr><p>******-—-<br>-—</p><h3 id="脚注-amp-注解"><a href="#脚注-amp-注解" class="headerlink" title="脚注&amp;注解"></a>脚注&amp;注解</h3><p>这是一个脚注[^1]<br>[^1]: 这里是脚注</p><p>这是一个脚注[^1]<br>[^1]: 这里是脚注</p><h3 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h3><pre class=" language-math"><code class="language-math">E = mc^2</code></pre><p>```math<br>E = mc^2<br>```</p><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><pre><code>graph TD    A[aaa]--&gt;B(bbb)    B--&gt; C{ccc}    C--&gt;|One| D(ddd)    C--&gt;|Two| E(eee)    C--&gt;|Three| F(fff)</code></pre><h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><pre><code>ganttdateFormat YYYY-MM-DDtitle 产品计划表section 初期阶段明确需求: 2019-05-01, 10dsection 中期阶段跟进开发: 2019-05-11, 9dsection 后期阶段测试上线: 2019-05-20, 9d</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><!--注释是给自己看的，预览时也不会出现，当然发布出去别人也不会看见。--><p>&lt;!–注释是给自己看的，预览时也不会出现，当然发布出去别人也不会看见。–&gt;</p><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>这里<br>换行了<br>这里&lt;br/&gt;换行了</p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p><u>这是一个下划线文字</u><br>&lt;u&gt;这是一个下划线文字</p><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>\<em>literal asterisks\</em></p>]]></content>
      
      
      <categories>
          
          <category> 编码工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MarkDown </tag>
            
            <tag> 标记语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
